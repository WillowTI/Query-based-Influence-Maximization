## 运行环境

Cygwin + CLion



## 环境变量

something like

-dataset nethept/ -k 50 -model IC -epsilon 0.1

## 如何计算影响力
给定一个点集，如何计算这个点集在图上的影响力。最原始的方法是用蒙特卡洛模拟，在图上模拟影响的过程，但是时间消耗很大。这里给出两种方法，不一定可行，作为思路可以参考。
+ 一种方法是计算RRSet中有多少项包括了点集中至少一个点，Influence_IC_RRSet方法对应这个计算方式。本算法采用此方式
+ 另一种方法是在采样的过程保存某个点能影响哪些点，遍历结果点集，计算这些点能影响的点的交集。

## 建立FP-Tree索引

用FP-Tree这个词不太准确，因为没有“删除计数小于min-support”这一操作。更准确的说法是Trie树，不过没多大差别，后面还是用FP-Tree。
+ 先扫描RRSet，统计每个点出现的次数，然后给每一个项按照出现的次数从小到大排序，这一步时间开销可能会很大，但是必须执行
+ 然后再次扫描排序后的RRSet，遍历每一个项，建立FP-Tree。
+ 树需要支持插入操作，接受一个vector作为参数，删除和搜索功能可以先不做。
+ 需要一个链表数组记录每一个点出现的trie_node，在删除点的时候，遍历这个链表数组，向上删除，父节点计数-=自身计数，如果计数为0，还要删除自身节点；向下删除，递归子节点，子节点的计数-=子节点自身计数
+ 树的节点需要保存指向父节点的指针，指向子节点的指针vector，记录节点->下标的map，自身的次数，链表的next指针（这可以用一个vector记录）
+ 一般Trie树为所有可能的子节点预留了位置，但是由于节点树众多，要是给每个节点预留位置的话，空间消耗将十分大，所以选择在需要的时候申请空间，添加到vector中，在map中添加位置信息
+ 再用Trie维护的时候要不要像原来暴力维护一样考虑某一个pattern用过了，不能再用？没有必要，因为删点不管先删度小的还是先删度为大的，都不会有重复删的问题，所以在设计trie_maintain这个函数的时候没有用vis
+ 删除点的时候，当点的度为0可以释放这个点，但是发现当数据规模比较大的时候会直接崩溃，数据规模比较小的时候没事。不释放也没有关系，但是空间使用可能会更高
+ 删除degeneracy最低的点的时候，一种方法是直接取degeneracy最高的budget个点，这个方法更快；另一种方法是每次删除degeneracy最低的点，然后根据原图，维护每个点的degeneracy。原始数据集跑一遍，前者效果更好，不知道是特例，还是什么，后面拿不同的数据集测一遍
+ 打算用邻接表保存树，把索引的大小和原来的大小做比较